## 服务器集群的伸缩性设计常见方法
#### 垂直扩展（Scale Up）与水平扩展（Scale Out）
1. HTTP重定向 
Web服务器可通过Http响应头信息中的Location标记来返回一个新的URL，浏览器自动去访问这个新的URL。
2. DNS负载均衡
DNS负责将用户请求的域名映射为实际的IP地址，这种映射可以是一对多的（ DNS轮询， DNS的A记录，用来指定域名对应的多个IP地址），这样DNS服务器便充当负载均衡调度器。
3. 反向代理负载均衡（站点层）
反向代理服务器的核心工作是转发HTTP，它工作在HTTP层面，因此，基于反向代理的负载均衡也称为七层负载均衡。（NGINX）
4. IP负载均衡
网络地址转换(NAT)负载均衡工作在传输层，对数据包中的IP地址和端口进行修改，从而达到转发的目的，称为四层负载均衡。 
5. 直接路由
这种方式工作在数据链路层。它修改数据包的目标MAC地址，并没有修改目标IP（因为这种转发工作在数据链路层，它对上层端口无能为力），然后发给实际的服务器，实际服务器的响应数据直接发回给用户，而不用经过调度器。但实际服务器必须接入外网，而且不能将调度器作为默认网关，要给实际服务器添加和调度器IP地址相同的IP别名。
6. IP隧道
基于IP隧道的负载均衡系统也可以使用LVS来实现，称为LVS-TUN。与LVS-DR不同的是，实际服务器和调度器可以不在同一个WAN网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器必须有合法的IP地址。基于IP隧道的请求转发机制，是将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。基于IP隧道的独特方式，可以将实际服务器部署在不同的地域并根据就近原则转移请求，比如一些CDN服务器就是基于IP隧道技术实现的。

db scale:  
1. 水平拆分数据库  
顺序拆分：a存1-100， b存101-200  
hash拆分  
（1）每个服务器上存储的数据量是总量的1/n，所以单机的性能也会有提升；  
（2）n个服务器上的数据没有交集，那个服务器上数据的并集是数据的全集；  
（3）数据水平拆分到了n个服务器上，理论上读性能扩充了n倍，写性能也扩充了n倍（其实远不止n倍，因为单机的数据量变为了原来的1/n）；  
2。 同步读写  
（1）每个服务器上存储的数据量是和总量相同；  
（2）n个服务器上的数据都一样，都是全集；  
（3）理论上读性能扩充了n倍，写仍然是单点，写性能不变；  

# 高可用
- 方法论上，高可用保证的原则是“集群化”，或者叫“冗余”。 
- 通过“自动故障转移”来实现系统的高可用。

【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。分别如下：

### 反向代理层
以nginx为例，有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。

### 站点层
【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。 自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。

### 服务层
【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。

### 缓存层
缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。
以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。
说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。

### 数据库层
主从同步，读写分离
### 读库高可用

### 写库高可用

