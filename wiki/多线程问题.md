# 多线程问题

## 1.线程与进程：
进程是运行中的程序，是系统进行资源分配和调用的独立单位，具有自己的系统资源和内存空间，切换代价大

线程是进程中的一份执行序列，一个进程可以包含多个线程，一个进程中的线程共享进程资源。切换代价小
http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html（简易解释）

## 2.多线程的创建和启动：
一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。调用start（）方法将线程设置为可运行状态，什么时候执行由操作系统决定

## 3.中断线程：
 当一个线程运行时，另一个线程可以调用对应的 Thread 对象的 interrupt()方法来中断它，该 方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。但是如果此时线程处于阻塞状态（sleep或者wait），就无法检查中断状态，此时会抛出InterruptedException异常。

boolean isInterrupted()：判断线程是否被中断，这个方法的调用不会产生副作用即不改变线程的当前中断状态。
static Thread currentThread() : 返回代表当前执行线程的Thread对象。注意的是，如果只是单纯的调用 interrupt()方法，线程并没有实际被中断，会继续往下执行。

## 4.守护线程：
首先我们可以通过t.setDaemon(true)的方法将线程转化为守护线程。而守护线程的唯一作用就是为其他线程提供服务。JVM的垃圾回收、内存管理等线程都是守护线程

## 5.线程优先级
在现代操作系统中基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着   下一次分配。

_线程分配到的时间片多少也决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。_

在java线程中，通过一个整型的成员变量Priority来控制线程优先级，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用setPriority方法提高或降低任何一个线程优先级。可以将优先级设置在MIN_PRIORITY（在Thread类定义为1）与MAX_PRIORITY（在Thread类定义为10）之间的任何值。线程的默认优先级为NORM_PRIORITY（在Thread类定义为5）。

## 6.线程的状态转化关系
>
•	新建状态（New）：新创建了一个线程对象。
•	就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
•	运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
•	阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
  - 等待阻塞（WAITING）：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
  - 同步阻塞（Blocked）：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
  - 超时阻塞（TIME_WAITING）：运行的线程执行sleep(long)或join(long)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
  
•	死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


## 7.线程同步问题 ：
_当多个线程同时操作共享数据时，会出现数据错误的现象

典型的两种方案：synchronized关键字 和 lock对象（可分为单锁和多锁）

## 8.线程间的通信机制:
synchronied关键字等待/通知机制 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，
线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述的两个线程通过对象O来完成交互，而对象上的wait()和notify()/notifyAll()的关系
就如同开关信号一样，用来完成等待方和通知方之间的交互工作。条件对象的等待/通知机制：所谓的条件对象也就是配合前面我们分析的Lock锁对象，通过锁对
象的条件对象来实现等待/通知机制。

(原文参考：http://blog.csdn.net/javazejian/article/details/50878598)

## 9.线程安全和非线程安全
 非线程安全是指多线程操作同一个对象可能会出现问题。而线程安全则是多线程操作同一个对象不会有问题。

## 10.线程池： 
在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程 
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 
第三：提高线程的可管理性。 
常用线程池：ExecutorService 是主要的实现类

## 11.同步与异步:
同步和异步关注的的是
__消息通信机制__。

同步通信机制是指，在发出一个调用时，在没有得到结果之前，改调用就不返回，但是一旦调用返回，就得到了返回值。
异步通信机制是指，调用在发出之后，这个调用就直接返回了，所以没有立刻返回结果。
另外，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写

## 12.阻塞和非阻塞：
阻塞和非阻塞关注的是
**程序在等待调用结果时的状态**。

阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果后才会返回。
非阻塞调用是指不能立刻得到结果之前，该调用就不会阻塞当前线程


